<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>petec.regexeng</title>
        </head><body>
        <h1>petec.regexeng</h1>
        <!-- Generated by Ddoc from regexeng.d -->
Regex engine based on ideas in Russ Cox's regex article:
  <a href="http://swtch.com/~rsc/regexp/regexp2.html">http://swtch.com/~rsc/regexp/regexp2.html</a>
<br><br>
Some implementation details and range API derived from std.regex

<br><br>
<b>Author:</b><br>
Peter Chadwick

<br><br>
<b>License:</b><br>
Boost Software License - Version 1.0 - August 17th, 2003
<br><br>

  Permission is hereby granted, free of charge, to any person or organization
  obtaining a copy of the software and accompanying documentation covered by
  this license (the "Software") to use, reproduce, display, distribute,
  execute, and transmit the Software, and to prepare derivative works of the
  Software, and to permit third-parties to whom the Software is furnished to
  do so, all subject to the following:
<br><br>

  The copyright notices in the Software and this entire statement, including
  the above license grant, this restriction and the following disclaimer,
  must be included in all copies of the Software, in whole or in part, and
  all derivative works of the Software, unless such copies or derivative
  works are solely in the form of machine-executable object code generated by
  a source language processor.
<br><br>

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.

<br><br>
<b>History:</b><br>
2010-10    Started
<br><br>

    2011-02    Replaced recursive calls with loops
<br><br>

    2011-02    Add backtracking engine<br><br>

<dl><dt><big>BackTrackEngine <u>btregex</u>(String)(String <i>s</i>);
</big></dt>
<dd>Creates a back tracking regular expression engine
<br><br>
<b>Params:</b><br>
<table><tr><td>s</td>
<td>The regular expression</td></tr>
</table><br>
<b>Returns:</b><br>
The regular expression engine<br><br>

</dd>
<dt><big>LockStepEngine <u>lsregex</u>(String)(String <i>s</i>);
</big></dt>
<dd>Create a Thompson style regular expression engine
<br><br>
<b>Params:</b><br>
<table><tr><td>s</td>
<td>The regular expression</td></tr>
</table><br>
<b>Returns:</b><br>
The regular expression engine<br><br>

</dd>
<dt><big>struct <u>Match</u>(String);
<br>struct <u>Match</u>(String,int NumCaptures);
</big></dt>
<dd><u>Match</u> types
<br><br>
Stores information about a regular expression match.
<br><br>

 If known at compile time, using a <u>Match</u> type parameterised on the
 number of captures avoids dynamic allocation of storage for them.<br><br>

<dl><dt><big>void <u>setNumCaptures</u>(int <i>numCaptures</i>);
</big></dt>
<dd>Set the number of captures<br><br>

</dd>
<dt><big>String <u>opIndex</u>(uint <i>i</i>);
</big></dt>
<dd>Get the capture <i>i</i>'th capture<br><br>

</dd>
<dt><big>size_t <u>length</u>();
</big></dt>
<dd>Get the number of captures<br><br>

</dd>
<dt><big>size_t <u>startMatch</u>();
</big></dt>
<dd>Get the position in the string of the start of the  match<br><br>

</dd>
<dt><big>size_t <u>endMatch</u>();
</big></dt>
<dd>Get the position in the string of the end of the  match<br><br>

</dd>
</dl>
</dd>
<dt><big>MatchRange!(String,Regex,Match!(String)) <u>match</u>(String, Regex)(String <i>s</i>, Regex <i>re</i>);
</big></dt>
<dd>Create a MatchRange object that may be used to iterate over the matches.
<br><br>
<b>Params:</b><br>
<table><tr><td>s</td>
<td>The string to <u>match</u></td></tr>
<tr><td>re</td>
<td>The regular expression engine</td></tr>
</table><br>
<b>Returns:</b><br>
The MatchRange object

<br><br>
<b>Example:</b><br>
<pre class="d_code"> <font color=blue>foreach</font>( m; <u>match</u>( <font color=red>"She sells sea shells on the sea shore"d</font>, btregex( <font color=red>`\b(?i)s\w+`</font> ) ) )
 {
     writefln( <font color=red>"%s[%s]%s"</font>, m.pre(), m.hit(), m.post() );
 }

 <font color=green>// Prints:
</font> <font color=green>// [She] sells sea shells on the sea shore
</font> <font color=green>// She [sells] sea shells on the sea shore
</font> <font color=green>// She sells [sea] shells on the sea shore
</font> <font color=green>// She sells sea [shells] on the sea shore
</font> <font color=green>// She sells sea shells on the [sea] shore
</font> <font color=green>// She sells sea shells on the sea [shore]
</font>
</pre>
<br><br>

</dd>
<dt><big>MatchRange!(String,Regex,Match!(String,NumCaptures)) <u>staticMatch</u>(int NumCaptures, String, Regex)(String <i>s</i>, Regex <i>re</i>);
</big></dt>
<dd>Create a MatchRange object with a statically defined number of caputres.
<br><br>
<b>Example:</b><br>
<pre class="d_code"> <font color=blue>auto</font> sm = <u>staticMatch</u>!3( <font color=red>"123.456"d</font>, btregex( <font color=red>`([0-9]+)\.([0-9]+)`</font> ) );
 <font color=blue>assert</font>( sm.captures[0] == <font color=red>"123.456"</font> );
 <font color=blue>assert</font>( sm.captures[1] == <font color=red>"123"</font> );
 <font color=blue>assert</font>( sm.captures[2] == <font color=red>"456"</font> );
</pre>
<br><br>

</dd>
<dt><big>struct <u>MatchRange</u>(String,RegexEngine,MatchType);
</big></dt>
<dd>Range interface for regular expression matches<br><br>

<dl><dt><big>bool <u>empty</u>();
<br>void <u>popFront</u>();
<br>MatchRange!(String,RegexEngine,MatchType) <u>front</u>();
</big></dt>
<dd>Range primitives<br><br>

</dd>
<dt><big>Captures!(String,MatchType) <u>captures</u>();
</big></dt>
<dd>Get captured subexpressions<br><br>

</dd>
<dt><big>String <u>pre</u>();
</big></dt>
<dd>Return the portion of the string before the match<br><br>

</dd>
<dt><big>String <u>hit</u>();
</big></dt>
<dd>Return portion of the string that matches the regular expression<br><br>

</dd>
<dt><big>String <u>post</u>();
</big></dt>
<dd>Return the portion of the string after the match<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>Captures</u>(String,MatchType);
</big></dt>
<dd>Range interface for captured subexpressions of a match<br><br>

<dl><dt><big>String <u>opIndex</u>(uint <i>i</i>);
</big></dt>
<dd>Return the subexpression corresponding to the given index.
<br><br>
Index 0 is the entire match.<br><br>

</dd>
<dt><big>bool <u>empty</u>();
<br>void <u>popFront</u>();
<br>String <u>front</u>();
</big></dt>
<dd>Range primitives<br><br>

</dd>
<dt><big>size_t <u>length</u>();
</big></dt>
<dd>Number of captures<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. </small>
        </body></html>
