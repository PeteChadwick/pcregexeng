<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>petec.regexeng</title>
        </head><body>
        <h1>petec.regexeng</h1>
        <!-- Generated by Ddoc from regexeng.d -->
Regex engine based on ideas in Russ Cox's regex article:
  <a href="http://swtch.com/~rsc/regexp/regexp2.html">http://swtch.com/~rsc/regexp/regexp2.html</a>
<br><br>
The Range based API is modelled on the std.regex library by Walter
  Bright and Andrei Alexandrescu. Some implementation ideas, such as
  the character bitmap instruction are also based on std.regex.

<br><br>
<b>Author:</b><br>
Peter Chadwick

<br><br>
<b>License:</b><br>
Boost Software License - Version 1.0 - August 17th, 2003
<br><br>

  Permission is hereby granted, free of charge, to any person or organization
  obtaining a copy of the software and accompanying documentation covered by
  this license (the "Software") to use, reproduce, display, distribute,
  execute, and transmit the Software, and to prepare derivative works of the
  Software, and to permit third-parties to whom the Software is furnished to
  do so, all subject to the following:
<br><br>

  The copyright notices in the Software and this entire statement, including
  the above license grant, this restriction and the following disclaimer,
  must be included in all copies of the Software, in whole or in part, and
  all derivative works of the Software, unless such copies or derivative
  works are solely in the form of machine-executable object code generated by
  a source language processor.
<br><br>

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.

<br><br>
<b>History:</b><br>
2010-10    Started
<br><br>

    2011-02    Replaced recursive calls with loops
<br><br>

    2011-02    Add backtracking engine
<br><br>

    2011-03    Add some documentation<br><br>

<dl><dt><big>BackTrackEngine <u>btregex</u>(String)(String <i>s</i>, string <i>flags</i> = null);
<br>LockStepEngine <u>lsregex</u>(String)(String <i>s</i>, string <i>flags</i> = null);
<br>alias <u>regex</u>;
</big></dt>
<dd>Functions to create regular expression engines.
<br><br>
<dl><dt><u>btregex</u></dt> <dd>Creates a back tracking regular expression engine.</dd>
 <dt>lsregex</dt> <dd>Create a Thompson style regular expression engine.</dd>
 <dt>regex</dt> <dd>An alias for the <u>btregex</u> function.</dd></dl>

<br><br>
<b>Params:</b><br>
<table><tr><td>s</td>
<td>The regular expression</td></tr>
<tr><td>flags</td>
<td>Regular expression flags:
           <dl>            <dt>i</dt> <dd>Case insensitive</dd>
             <dt>m</dt> <dd>Multi line mode</dd></dl></td></tr>
</table><br>
<b>Returns:</b><br>
The regular expression engine<br><br>

</dd>
<dt><big>struct <u>RegexSingleMatch</u>(String);
<br>struct <u>RegexSingleMatch</u>(String,int NumCaptures);
</big></dt>
<dd><u>RegexSingleMatch</u> types
<br><br>
Stores information about a regular expression match.
<br><br>

 If known at compile time, using a <u>RegexSingleMatch</u> type parameterised on the
 number of captures avoids dynamic allocation of storage for them.<br><br>

<dl><dt><big>void <u>setNumCaptures</u>(int <i>numCaptures</i>);
</big></dt>
<dd>Set the number of captures<br><br>

</dd>
<dt><big>String <u>opIndex</u>(uint <i>i</i>);
</big></dt>
<dd>Get the capture <i>i</i>'th capture<br><br>

</dd>
<dt><big>size_t <u>length</u>();
</big></dt>
<dd>Get the number of captures<br><br>

</dd>
<dt><big>size_t <u>startMatch</u>();
</big></dt>
<dd>Get the position in the string of the start of the  match<br><br>

</dd>
<dt><big>size_t <u>endMatch</u>();
</big></dt>
<dd>Get the position in the string of the end of the  match<br><br>

</dd>
</dl>
</dd>
<dt><big>RegexMatch!(String,Regex,RegexSingleMatch!(String)) <u>match</u>(String, Regex)(String <i>s</i>, Regex <i>re</i>);
</big></dt>
<dd>Create a RegexMatch object that may be used to iterate over the matches.
<br><br>
<b>Params:</b><br>
<table><tr><td>s</td>
<td>The string to <u>match</u></td></tr>
<tr><td>re</td>
<td>The regular expression engine</td></tr>
</table><br>
<b>Returns:</b><br>
The RegexMatch object

<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=green>// Evaluates to boolean for conditional expressions
</font> <font color=blue>auto</font> m = <u>match</u>( <font color=red>"Hello"</font>, regex( <font color=red>"H(.*)o"</font> ) );

 <font color=green>// Retrieve captures subexpressions
</font> <font color=blue>assert</font>( m.captures[1] == <font color=red>"ell"</font> );

 <font color=green>// Iterate over matches with range interface
</font> <font color=blue>foreach</font>( m; <u>match</u>( <font color=red>"She sells sea shells on the sea shore"</font>, regex( <font color=red>`\b(?i)s\w+`</font> ) ) )
 {
     writefln( <font color=red>"%s[%s]%s"</font>, m.pre(), m.hit(), m.post() );
 }

 <font color=green>// Prints:
</font> <font color=green>// [She] sells sea shells on the sea shore
</font> <font color=green>// She [sells] sea shells on the sea shore
</font> <font color=green>// She sells [sea] shells on the sea shore
</font> <font color=green>// She sells sea [shells] on the sea shore
</font> <font color=green>// She sells sea shells on the [sea] shore
</font> <font color=green>// She sells sea shells on the sea [shore]
</font>
</pre>
<br><br>

</dd>
<dt><big>RegexMatch!(String,Regex,RegexSingleMatch!(String,NumCaptures)) <u>staticMatch</u>(int NumCaptures, String, Regex)(String <i>s</i>, Regex <i>re</i>);
</big></dt>
<dd>Create a RegexMatch object with a statically defined number of caputres.
<br><br>
<b>Example:</b><br>
<pre class="d_code"> <font color=blue>auto</font> sm = <u>staticMatch</u>!3( <font color=red>"123.456"</font>, btregex( <font color=red>`([0-9]+)\.([0-9]+)`</font> ) );
 <font color=blue>assert</font>( sm.captures[0] == <font color=red>"123.456"</font> );
 <font color=blue>assert</font>( sm.captures[1] == <font color=red>"123"</font> );
 <font color=blue>assert</font>( sm.captures[2] == <font color=red>"456"</font> );
</pre>
<br><br>

</dd>
<dt><big>struct <u>RegexMatch</u>(String,RegexEngine,RegexSingleMatchType);
</big></dt>
<dd>Range interface for regular expression matches<br><br>

<dl><dt><big>bool <u>empty</u>();
<br>void <u>popFront</u>();
<br>RegexMatch!(String,RegexEngine,RegexSingleMatchType) <u>front</u>();
</big></dt>
<dd>Range primitives<br><br>

</dd>
<dt><big>Captures!(String,RegexSingleMatchType) <u>captures</u>();
</big></dt>
<dd>Get captured subexpressions<br><br>

</dd>
<dt><big>String <u>pre</u>();
</big></dt>
<dd>Return the portion of the string before the match<br><br>

</dd>
<dt><big>String <u>hit</u>();
</big></dt>
<dd>Return portion of the string that matches the regular expression<br><br>

</dd>
<dt><big>String <u>post</u>();
</big></dt>
<dd>Return the portion of the string after the match<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>Captures</u>(String,RegexSingleMatchType);
</big></dt>
<dd>Range interface for captured subexpressions of a match<br><br>

<dl><dt><big>String <u>opIndex</u>(uint <i>i</i>);
</big></dt>
<dd>Return the subexpression corresponding to the given index.
<br><br>
Index 0 is the entire match.<br><br>

</dd>
<dt><big>bool <u>empty</u>();
<br>void <u>popFront</u>();
<br>String <u>front</u>();
</big></dt>
<dd>Range primitives<br><br>

</dd>
<dt><big>size_t <u>length</u>();
</big></dt>
<dd>Number of captures<br><br>

</dd>
</dl>
</dd>
<dt><big>String1 <u>replace</u>(String1, RegexEngine, String2)(String1 <i>s</i>, RegexEngine <i>re</i>, String2 <i>pattern</i>);
<br>String1 <u>replaceFirst</u>(String1, RegexEngine, String2)(String1 <i>s</i>, RegexEngine <i>re</i>, String2 <i>pattern</i>);
</big></dt>
<dd>Replace regular expression match occurrences is string.
<br><br>
<u>replace</u> will <u>replace</u> all occurrences, replaceFirst replaces only the first.

<br><br>
<b>Params:</b><br>
<table><tr><td>s</td>
<td>The string to <u>replace</u> match occurrences in.</td></tr>
<tr><td>re</td>
<td>The regular expression engine</td></tr>
<tr><td>pattern</td>
<td>The replacement pattern. The codes below will be substituted:
           <dl>          <dt>$n</dt> <dd>Substitute with the nth capture</dd>
           <dt>$$</dt> <dd>Outputs a single $</dd></dl></td></tr>
</table><br>
<b>Returns:</b><br>
The resulting string

<br><br>
<b>Examples:</b><br>
<pre class="d_code"> string before = <font color=red>`-- '1', '2', '3', '4' --`</font>;
 string after = <font color=red>`-- "1", "2", "3", "4" --`</font>;
 string after2 = <font color=red>`-- "1", '2', '3', '4' --`</font>;
 <font color=blue>assert</font>( <u>replace</u>( before, regex( <font color=red>`'([^']+)'`</font> ), <font color=red>`""`</font> ) == after );
 <font color=blue>assert</font>( replaceFirst( before, regex( <font color=red>`'([^']+)'`</font> ), <font color=red>`""`</font> ) == after2 );
</pre>
<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. </small>
        </body></html>
